1. 面向对象和面向过程的区别

面向过程：
　　优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
缺点：没有面向对象易维护、易复用、易扩展
面向对象：
　　优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
缺点：性能比面向过程低

2. Java语言有哪些特点？
　　1，简单易学；2，面向对象（封装，继承，多态）；3，平台无关性（Java虚拟机实现平台无关性）；4，可靠性；5，安全性；6，支持多线程（C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而Java语言却提供了多线程支持）；7，支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的，因此Java语言不仅支持网络编程而且很方便）；8，编译与解释并存；

3. 什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？

先看下java中的编译器和解释器：
　　Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。
Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。

采用字节码的好处：

　　Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。

虚拟机是什么
任何一种可以运行Java字节码的软件均可看成是Java的虚拟机（JVM）

4. 什么是Java程序的主类？应用程序和小程序的主类有何不同？
   一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main（）方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。

5. 什么是JDK?什么是JRE？
   JDK:顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。
   JRE:普通用户而只需要安装JRE（Java Runtime Environment）来 来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。

6. 环境变量Path和ClassPath的作用是什么？如何设置这两个环境变量？
    Path环境变量:
    安装完JDK(Java Development Kit，Java开发套件)之后，可以在安装目录下找到两个子目录(bin目录和lib目录)。bin目录中包含着Java编译器等可执行文件。

    如果要运行执行java命令，必须得执行java命令对应的可执行文件的路径，通常有两种方式：

    在%JAVA_HOME%目录下执行。
    执行命令的时候，指明路径%JAVA_HOME%/bin/java

    但是，这样不是特别方便，这就是为什么配置环境变量。如果将%JAVA_HOME%/bin/，添加到环境变量PATH中。再执行java命令时(无论在哪个目录下执行)，系统就会从左到右搜索(这里的顺序很重要，可以利用这个特性覆盖掉某个旧版本的jdk。)环境变量PATH中执行的目录，直到找到对应的可执行文件并执行(找到之后，后面的目录都会被忽略掉)。如果找不到，提示该命令不存在。这就是PATH环境变量的作用。

    如何配置:
    另外，由于JDK的安装目录中的%JAVA_HOME%/jre/bin目录下也有一些常用的工具，所以一般也将其配置到PATH环境变量中。同时，在配置java环境的同事，不能影响其它环境的运行。所以，以windows下面环境变量的配置(各个目录之间用;隔开)为例，通常将下面的内容加到PATH环境变量的最左侧：
    %JAVA_HOME%/bin/;%JAVA_HOME%/jre/bin

    CLASSPATH环境变量
    和PATH变量不同，CLASSPATH环境变量的作用是指定Java类所在的目录(或许它的意思就是PATH of Class)。
    CLASSPATH环境变量的作用是指定Java类所在的目录。
    ps：如果刚装完JDK，没有配置环境变量，那么缺省的%CLASSPATH%环境变量的值是.，也就是当前目录。

7. Java应用程序与小程序之间有那些差别？
简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。
    字符型常量和字符串常量的区别:
    1) 形式上:
　　　　字符常量是单引号引起的一个字符
　　　　字符串常量是双引号引起的若干个字符
　　2) 含义上:
　　　　字符常量相当于一个整形值(ASCII值),可以参加表达式运算
　　　　字符串常量代表一个地址值(该字符串在内存中存放位置)
　　3) 占内存大小
　　　　字符常量只占一个字节
　　　　字符串常量占若干个字节(至少一个字符结束标志)

8. Java语言采用何种编码方案？有何特点？
    Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。

9. 构造器Constructor是否可被override
    在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以Constructor也就不能被override,但是可以overload,所以你可以看到一个类中有多个构造函数的情况。

10. 重载和重写的区别
重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。
重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。

11. java 面向对象三大特性（封装，继承，多态）以及抽象、接口的介绍，访问控制符public,protected,private,以及默认的区别
封装：
1.定义：隐藏对象的属性和实现细节，仅对外公开接口,控制在程序中属性的读和修改的访问级别。
2.封装的目的是：增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员。
3.封装的基本要求是:把所有的属性私有化，对每个属性提供getter和setter方法，如果有一个带参的构造函数的话，那一定要写一个不带参的构造函数。在开发的时候经常要对已经编写的类进行测试，所以在有的时候还有重写toString方法，但这不是必须的。
继承：
1.目的：实现代码的复用。
2.介绍：当两个类具有相同的特征（属性）和行为（方法）时，可以将相同的部分抽取出来放到一个类中作为父类，其它两个类继承这个父类。继承后子类自动拥有了父类的属性和方法，但特别注意的是，父类的私有属性和构造方法并不能被继承。另外子类可以写自己特有的属性和方法，目的是实现功能的扩展，子类也可以复写父类的方法即方法的重写。子类不能继承父类中访问权限为private的成员变量和方法。子类可以重写父类的方法，及命名与父类同名的成员变量。有时候我们需要这样的需求：我们需要将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。这个时候就需要使用到protected。

类成员访问修饰符与访问能力之间的关系（类成员访问权限）：
    |      类型     | Private | 无修饰 | Protected | Public |
    |  ------------ | ------- | ------ | -------- | ------ |
    |    同一个类    |  可访问   |  可访问  |  可访问  |  可访问  |
    | 同一包中的子类  |  不可访问  |  可访问  |  可访问  |  可访问  |
    | 同一包中的非子类 |  不可访问  |  可访问  |  可访问  |  可访问  |
    |  不同包中的子类  |  不可访问  |  不可访问  |  可访问  |  可访问  |
    | 不同包中的非子类 |  不可访问  |  不可访问  |  不可访问  |  可访问  |

继承和权限：
    |      类型     |       Public        |       无修饰        |         private        | protect | final | abstract | static |
    |  ----------- | ------------------- | ------------------- | ---------------------- | ------- | ------ | ------- | ------- |
    |     类继承    |        可继承        |   只有同一包中可继承   |        不能修饰类       |  不能修饰类 |不能派生子类｜一般可继承｜不能修饰类｜
    |    方法重载   |        可重载         |       可重载         |        不能重载         |  可重载   |  不可重载 ｜  可重载  ｜  可重载 ｜
    |    成员变量   |父类属性被隐藏(使用super)|父类属性被隐藏(使用super)|子类不能直接访问父类的私有变量|父类属性被隐藏(使用super)|必须赋初值｜不可修饰成员变量｜每个实例共享这个类变量｜

多态：
1.概念：相同的事物，调用其相同的方法，参数也相同时，但表现的行为却不同。
2.Java实现多态有三个必要条件：继承、重写、向上转型。
继承：在多态中必须存在有继承关系的子类和父类。
重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。
只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。
3.多态的实现方式：
（1）基于继承实现的多态
基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。
（2）基于接口实现的多态
继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。
在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。
继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。
4.多态性主要表现在如下两个方面:
(1)方法重载.通常指在同一个类中,相同的方法名对应着不同的方法实现,但是方法的参数不同.
(2)成员覆盖.通常指在不同类(父类和子类)中,允许有相同的变量名,但是数据类型不同;也允许有相同的方法名，但是对应的方法实现不同.
5.多态的好处：程序的可扩展性及可维护性增强。
抽象：
1.介绍：在面向对象的概念中，我们知道所有的对象都是通过类来描绘的，但是并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类往往用来表征我们在对问题领域进行分析、 设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象，我们不能把它们实例化（拿不出一个具体的东西）所以称之为抽象。
比如：我们要描述“水果”，它就是一个抽象，它有质量、体积等一些共性（水果有质量），但又缺乏特性（苹果、橘子都是水果，它们有自己的特性），我们拿不出唯一一种能代表水果的东西（因为苹果、橘子都不能代表水果），可用抽象类来描述它，所以抽象类是不能够实例化的。当我们用某个类来具体描述“苹果”时，这个类就可以继承描述“水果”的抽象类，我们都知道“苹果”是一种“水果”。
2.抽象方法：被abstract修饰的方法是抽象方法，抽象方法没有方法体。修饰符 abstract 返回值类型 函数名();抽象方法的修饰符只能用public或者protected或者没有修饰，不能被final，static，private修饰。
（1）、类即使不包含抽象方法，也可以定义成抽象类。
（2）、类中含有抽象方法的类一定要定义成抽象类。
（3）、抽象类中字段的定义和子类的访问与一般类没有变化。
（4）、扩展抽象类有两种方法，第一种是在子类中定义部分抽象方法或者抽象方法不定义，这样子类也必须定义成抽象类，第二种是定义全部的抽象方法，这样子类就可以不定义成抽象的了。
（5）、抽象类不能被实例化，但是可以定义一个抽象类的对象变量，这个变量可以引用非抽象子类的对象。
（6）、抽象类中包含有构造方法，也可以显式书写构造方法，构造方法在实例化子类的对象中调用。
接口与抽象类的区别:
不同点：
1、接口可以多实现，而抽象类只能单继承
2、抽象类可以有非抽象的方法和构造方法、变量，但是接口只能有抽象方法，静态常量。
3、抽象类和子类具有父子关系，子类能拥有父类中一些属性。接口虽然某个类实现一个接口，但是由于接口中的变量都为静态常量，不存在继承关系。
相同点：
1、无论接口还是抽象类，都无法直接实例化，其自身实例化需要靠实现类或子类来实现。
2、接口和抽象类都必须实现其中的所有方法。
抽象类（abstract class）的定义方式如下：
```
public abstract class AbstractClass //里面至少有一个抽象方法
{
　　public int t; //普通数据成员
　　public abstract void method1(); //抽象方法，抽象类的子类在类中必须实现抽象类中的抽象方法
　　public abstract void method2();
　　public void method3(); //非抽象方法
　　public int method4();
　　publi int method4 (){
　　……//抽象类中可以赋予非抽象方法方法的默认行为，即方法的具体实现
　　}
    public void method3(){
　　……//抽象类中可以赋予非抽象方法方法的默认行为，即方法的具体实现
　　}
}
```

接口（interface）的定义方式如下：
```
public interface Interface
{
　　static final int i; //接口中不能有普通数据成员，只能够有静态的不能被修改的数据成员,static表示全局，final表示不可修改，可以不用static final修饰，会隐式的声明为static和  final 
    public void method1(); //接口中的方法一定是抽象方法，所以不用abstract修饰
    public void method2();//接口中不能赋予方法的默认行为，即不能有方法的具体实现
}
```

1、一个接口可以被多个类实现，一个类也可以实现多个接口。
2、接口中所有的定义的字段默认都是public static final 的属性，写和不写没有区别。
3、接口中的方法都是抽象的方法，并且抽象的方法默认都是public abstract修饰的，不能用其他的修饰符修饰，可以不写。
4、接口中没有构造方法
5、接口不是类，尤其不能使用new运算符实例化一个接口。但是可以声明接口的变量，这个变量可以指向实现了此接口的子类。
简言之抽象类是一种功能不全的类，接口只是一个抽象方法声明和静态不能被修改的数据的集合，两者都不能被实例化。
　　从某种意义上说，接口是一种特殊形式的抽象类，在ｊａｖａ语言中抽象类表示的是一种继承关系，一个类只能继承继承一个抽象类，而一个类却可以实现多个接口。在许多情况下，接口确实可以代替抽象类，如果你不需要刻意表达属性上的继承的话。
super的用法：
1.子类的构造函数如果要引用super的话，必须把super放在函数的首位.
```
class Base {
    Base() {
        System.out.println("Base");
    }
}
public class Checket extends Base {
    Checket() {
        super();//调用父类的构造方法，一定要放在方法的首个语句
        System.out.println("Checket");
    }
    public  static  void    main(String argv[]) {
        Checketc=newChecket();  
    }
}
```
如果想用super继承父类构造的方法，但是没有放在第一行的话，那么在super之前的语句，肯定是为了满足自己想要完成某些行为的语句，但是又用了super继承父类的构造方法。那么以前所做的修改就都回到以前了，就是说又成了父类的构造方法了。
2．在java中，有时还会遇到子类中的成员变量或方法与超类（有时也称父类）中的成员变量或方法同名。因为子类中的成员变量或方法名优先级高，所以子类中的同名成员变量或方法就隐藏了超类的成员变量或方法，但是我们如果想要使用超类中的这个成员变量或方法，就需要用到super.
```
classCountry {
    Stringname;
    void value() {
        name="China";
    }
}
class City extends Country {
    String name;
    void value() {
        name="Hefei";
        super.value();//不调用此方法时，super.name返回的是父类的成员变量的值null
        System.out.println(name);
        System.out.println(super.name);
    }   
    public static void main(String[] args) {
        City c=newCity();
        c.value();
    }
}
```
为了在子类中引用父类中的成员变量name和方法value()，在代码中使用了super、super.name和super.value(),若不调用super.value()时，super.name返回父类成员变量默认值null,调用此方法时，super.value()方法把成员变量name赋值为China,再利用super.name调用父类的成员变量的值。
另外，要注意的是super.name调用的是成员变量的值，
```
class Country {
    String name="xianfan";
    String value(String name) {
        name ="China";
        return name;
    }
}

class City extends Country {
    Stringname;
    String value(String name) {
        name ="Hefei";
        super.value("失败");//不调用此方法时，super.name返回的是父类的成员变量的值null
        System.out.println(name);
        System.out.println(super.name);
        return name;
    }
    public static void main(String[] args) {
        City c=newCity();
        c.value("成功");
    }
}
```
结果为：Hefei
xianfan
此时，super.name返回的值是父类成员变量的值xianfan,而此时的super.value()方法是不起作用的。

3．用super直接传递参数：
```
class Person {
    public static void prt(String s) {
        System.out.println(s);
    }
    Person() {
        prt("A Person.");   
    }
    Person(String name) {
        prt("A person name is:"+ name);
    }
}
public class Chinese extends Person {
    Chinese() {
        super();//调用父类构造函数（1）
        prt("A chinese.");// (4)
    }
    Chinese(String name) {
        super(name);//调用父类具有相同形参的构造函数（2）
        prt("his name is:"+ name);
    }   
    Chinese(String name,intage) {
        this(name);//调用当前具有相同形参的构造函数（3）
        prt("his age is:"+ age);
    }
    public static void main(String[] args) {
        Chinese cn = new Chinese();
        cn = new Chinese("kevin");
        cn = new Chinese("kevin", 22);
    }
}
```
结果为：A Person.
A chinese.
A person name is:kevin
his name is:kevin
A person name is:kevin
his name is:kevin
his age is:22

在这段程序中，this和super不再是像以前那样用“.”连接一个方法或成员，而是直接在其后跟上适当的参数，因此它的意义也就有了变化。super后加参数的是用来调用父类中具有相同形式的构造函数，如1和2处。this后加参数则调用的是当前具有相同参数的构造函数，如3处。当然，在Chinese的各个重载构造函数中，this和super在一般方法中的各种用法也仍可使用，比如4处，你可以将它替换为“this.prt”(因为它继承了父类中的那个方法）或者是“super.prt”（因为它是父类中的方法且可被子类访问），它照样可以正确运行。但这样似乎就有点画蛇添足的味道了。
this的用法：“this是指向对象本身的一个指针”
说明在什么情况下需要用到this：
第一、通过this调用另一个构造方法，用发是this(参数列表)，这个仅仅在类的构造方法中，别的地方不能这么用。
第二、函数参数或者函数中的局部变量和成员变量同名的情况下，成员变量被屏蔽，此时要访问成员变量则需要用“this.成员变量名”的方式来引用成员变量。当然，在没有同名的情况下，可以直接用成员变量的名字，而不用this。
第三、在函数中，需要引用该函所属类的当前对象时候，直接用this。
super和this的异同：
1)super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句）
2)this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）
3)super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名super.成员函数据名（实参）
4)this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）
5）调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。
6）super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。
7）super()和this()均需放在构造方法内第一行。
8）尽管可以用this调用一个构造器，但却不能调用两个。
9）this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。
10）this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。
11）从本质上讲，this是一个指向本对象的指针,然而super是一个Java关键字。
以下是关于子类父类的构造方法的注意事项：
1.如果子类没有定义构造方法，则调用父类的无参数的构造方法。
2.如果子类定义了构造方法，无论是无参数还是有参数，在创建子类的对象的时候，首先执行父类无参数的构造方法，然后执行自己的构造方法。
3.如果子类调用父类带参数的构造方法，可以通过super调用所需要的父类的构造方法。
4.如果某个构造方法调用类中的其他构造方法，则可以用this，且该语句放在构造方法的第一条。

12. java中equals方法的用法以及==的用法
equals 方法是 java.lang.Object 类的方法。
有两种用法说明：
（1）对于字符串变量来说，使用“==”和“equals()”方法比较字符串时，其比较方法不同。
“==”比较两个变量本身的值，即两个对象在内存中的首地址。
“equals()”比较字符串中所包含的内容是否相同。
比如：
String s1,s2,s3 = "abc", s4 ="abc" ;
s1 = new String("abc");
s2 = new String("abc");
那么：
s1==s2   是 false      //两个变量的内存地址不一样，也就是说它们指向的对象不 一样，
故不相等。
s1.equals(s2) 是 true    //两个变量的所包含的内容是abc，故相等。
注意（1）：
如果：StringBuffer s1 = new StringBuffer("a");
StringBuffer s2 = new StringBuffer("a");                  
结果：s1.equals(s2)  //是false
解释：StringBuffer类中没有重新定义equals这个方法，因此这个方法就来自Object类，
而Object类中的equals方法是用来比较“地址”的，所以等于false.
注意：
（1）对于s3和s4来说，有一点不一样要引起注意，由于s3和s4是两个字符串常量所生成的变量，其中所存放的内存地址是相等的，所以s3==s4是true（即使没有s3=s4这样一个赋值语句）
（2）对于非字符串变量来说，"=="和"equals"方法的作用是相同的都是用来比较其对象在堆内存的首地址，即用来比较两个引用变量是否指向同一个对象。
比如：
```
class A{
    A obj1   =   new  A();
    A obj2   =   new  A();
}
```
那么：obj1==obj2是false
obj1.equals(obj2)是false
但是如加上这样一句：obj1=obj2;
那么  obj1==obj2  是true
obj1.equals(obj2) 是true
总之：equals方法对于字符串来说是比较内容的，而对于非字符串来说是比较其指向的对象是否相同的。== 比较符也是比较指向的对象是否相同的也就是对象在对内存中的的首地址。
String类中重新定义了equals这个方法，而且比较的是值，而不是地址。所以是true。
关于equals与==的区别从以下几个方面来说： 
（1）如果是基本类型比较，那么只能用==来比较，不能用equals 
比如： 
```
public class TestEquals { 
    public static void main(String[] args){ 
        int a = 3; 
        int b = 4; 
        int c = 3; 
        System.out.println(a == b);//结果是false 
        System.out.println(a == c);//结果是true 
        System.out.println(a.equals(c));//错误，编译不能通过，equals方法 //不能运用与基本类型的比较 
    } 
}
```
（2） 对于基本类型的包装类型，比如Boolean、Character、Byte、Shot、Integer、Long、Float、Double等的引用变量，==是比较地址的，而equals是比较内容的。比如： 
```
public class TestEquals { 
    public static void main(String[] args){
        Integer n1 = new Integer(30); 
        Integer n2 = new Integer(30); 
        Integer n3 = new Integer(31); 
        System.out.println(n1 == n2);//结果是false 两个不同的Integer对象，故其地址不同， 
        System.out.println(n1 == n3);//那么不管是new Integer(30)还是new Integer(31) 结果都显示false 
        System.out.println(n1.equals(n2));//结果是true 根据jdk文档中的说明，n1与n2指向的对象中的内容是相等的，都是30，故equals比较后结果是true 
        System.out.println(n1.equals(n3));//结果是false 因对象内容不一样，一个是30一个是31 
    } 
} 
```
这是Integer的实例，如果是其他的比如Double、Character、Float等也一样。
（3） 注意：对于String(字符串)、StringBuffer(线程安全的可变字符序列)、StringBuilder(可变字符序列)这三个类作进一步的说明。 
（a）首先，介绍String的用法，请看下面的实例： 
```
public class TestEquals { 
    public static void main(String[] args) { 
        String s1 = "123"; 
        String s2 = "123"; 
        String s3 = "abc"; 
        String s4 = new String("123"); 
        String s5 = new String("123"); 
        String s6 = new String("abc"); 
        System.out.println(s1 == s2);//（1）true 
        System.out.println(s1.equals(s2));//（2）true 
        System.out.println(s1 == s3);//（3）flase 
        System.out.println(s1.equals(s3));//（4）flase 
        System.out.println(s4 == s5);//（5）flase 
        System.out.println(s4.equals(s5));//（6）true 
        System.out.println(s4 == s6);//（7）flase 
        System.out.println(s4.equals(s6));//（8）flase 
        System.out.println(s1 == s4);//（9）false 
        System.out.println(s1.equals(s4));//（10）true 
    } 
} 
```
答案解释：s1与s2分别指向由字符串常量”123” 创建的对象，在常量池中，只有一个对象，内容为123，有两个引用s1和s2指向这个对象，故这两个引用变量所指向的地址是相同的，因而（1）处的运行结果为true，又因为s1.equals(s2)是比较s1和s2所指向的对象的内容是否相等，而我们知道这两个对象的内容都是字符串常量”123”，故标记（2）处的运行结果是true。
用同样的方法分析，s1和s3所指向的对象不一样，内容也不一样，故标记（3）和（4）处运行结果是false。 
再看看s4和s5，这两个引用变量所指向的对象的内容都是一样的（内容都是123），但是这两个对象是用new操作符创建处类的，是在内存中分配两块空间给这两个对象的，因而这两个对象的内存地址不一样，故事两个不同的对象，标记（5）处的s4 == s5 运行结果为false，但是内容一样，故标记（6）处的s4.equals(s5)运行结果为true。同理，s4和s6所指向的对象地址不同，内容也不相同。故标记（7）（8）处运行结果为false。 
s1和s4分别指向两个不同的对象（之所以这样称呼，是因为这两个对象在内存中的地址不相同，故而对象不相同），故标记为（9）处的s1 == s4运行结果为false，而标记为（10）处的s1.equals(s4)运行结果为true.
（4） 再看一种情况，先看一个例子（该例子是Java编程思想第三章的例子）： 
```
class Value{ 
    int i; 
} 
public class EqualsMethod2 { 
    public static void main(String[] args) { 
        Value v1 = new Value(); 
        Value v2 = new Value(); 
        v1.i = v2.i = 100; 
        System.out.println(v1.equals(v2));//（1）flase 
        System.out.println(v1 == v2);//（2）true 
    } 
} 
```
运行结果疑问：乍一看结果，有点惊讶，为什么不是true呢，不是说equals方法是比较内容的吗？ 
解释：不错，如果在新类中被覆盖了equals方法，就可以用来比较内容的。但是在上面的例子中类Value并没有覆盖Object中的equals方法，而是继承了该方法，因此它就是被用来比较地址的，又v1和v2的所指向的对象不相同，故标记（1）处的v1.equals(v2)运行结果为false，标记为（2）处的v1 == v2运行结果也为false。 
13. String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？
可变性
　　String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。
线程安全性
　　String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。
性能
　　每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。
对于三者使用的总结：
如果要操作少量的数据用 = String
单线程操作字符串缓冲区 下操作大量数据 = StringBuilder
多线程操作字符串缓冲区 下操作大量数据 = StringBuffer

14. 自动装箱与拆箱
装箱：将基本类型用它们对应的引用类型包装起来；
拆箱：将包装类型转换为基本数据类型；
Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。

15. 类、方法、成员变量和局部变量的可用修饰符
一．类
类的修饰符：
Public:可以在其他任何类中使用，默认为统一包下的任意类。
Abstract:抽象类，不能被实例化，可以包含抽象方法，抽象方法没有被实现，无具体功能，只能衍生子类。
Final:不能被继承。

二．变量
变量修饰符：
一个类的成员变量的声明必须在类体中，而不能在方法中，方法中声明的是局部变量。
1.可访问修饰符：
2.static：类变量：一个类所拥有的变量，不是类的每个实例有的变量。类变量是指不管类创建了多少对象，系统仅在第一次调用类的时候为类变量分配内存，所有对象共享该类的类变量，因此可以通过类本身或者某个对象来访问类变量。
3.final：常量。
4.volatile：声明一个可能同时被并存运行的几个线程所控制和修改的变量。
实例变量：和类变量对应，即每个对象都拥有各自独立的实例变量。

三．方法：（和变量对象分为实例方法和类方法，并用有无static修饰区别）
类方法：使用static关键字说明的方法
1.第一次调用含类方法的类是，系统只为该类创建一个版本，这个版本被该类和该类的所有实例共享。
2.类方法只能操作类变量，不能访问实例变量。类方法可以在类中被调用，不必创建实例来调用，当然也可以通过对象来调用。
实例方法：实例方法可以对当前对象的实例变量操作，而且可以访问类变量。
方法可以重载，要求：方法名相同，但是参数必须有区别。（参数不同可以使类型不同，顺序不同，个数不同）
方法的返回类型：若无返回类型，则声明为void.

方法中的变量作用域：
1.成员变量：整个类。
2.局部变量：定义起到方法块结束为止。
3.方法参数：整个方法或者构造方法。
4.异常处理参数：参数传递给异常处理方法。
构造方法：和类同名的方法。为新建对象开辟内存空间后，用于初始化新建的对象。不能用对象显式的调用。
静态初始化器：格式：static{<赋值语句组>}
静态初始化器与构造方法的区别： 
静态初始化器
构造方法
对类的静态域初始化
对新建的对象初始化
类进入内存后，系统调用执行
执行new后自动执行
属特殊语句（仅执行一次）
属特殊方法
方法的修饰符：
抽象方法：用abstract修饰，只有声明部分，方法体为空，具体在子类中完成。
类方法：静态方法，用static修饰，
1.调用时，使用类名作为前缀，而不是类的某个实例对象名
2.不能被单独对象拥有，属于整个类共享。
3.不能处理成员变量。
最终方法：用final修饰，不能被子类重新定义的方法。
本地方法：用native修饰的方法，表示用其他语言书写的特殊方法，包括C，C++，FORTRAN，汇编语言等。
四．类成员的访问控制符：
即类的方法和成员变量的访问控制符，一个类作为整体对象不可见，并不代表他的所有域和方法也对程序其他部分不可见，需要有他们的访问修饰符判断。

16. 在一个静态方法内调用一个非静态成员为什么是非法的？
由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

17. 在Java中定义一个不做事且没有参数的构造方法的作用
Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。


