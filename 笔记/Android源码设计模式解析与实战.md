### 一.面向对象的六大原则

#### 1.单一职责原则，SRP

​		单一职责原则，Single Responsibility Principle，SRP的定义是：就一个类而言，应该仅有一个引起它变化的原因。

#### 2.开闭原则，OCP

​		让程序更稳定、更灵活，开闭原则，Open Close Principle，OCP的定义是：软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的。

#### 3.里氏替换原则，LSP

​		构建扩展性更好的系统，里氏替换原则，Liskov Substitution Principle，LSP的定义是：如果对每一个类型为S的对象O1，都有类型为T的对象O2，使得以T定义的所有程序P在所有的对象O1都代换成O2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。或称，所有引用基类的地方必须透明地使用其子类的对象。里氏替换原则的核心原理是抽象，抽象又依赖于继承这个特性。在OOP当中，继承的优缺点都相当明显。

优点有以下几点：

​		1.代码重用，减少创建类的成本，每个子类都拥有父类的方法和属性；

​		2.子类与父类基本相似，但又与父类有所区别；

​		3.提高代码的可扩展性。

继承的缺点：

​		1.继承是侵入性的，只要继承就必须拥有父类的所有属性和方法；

​		2.可能造成子类代码冗余、灵活性降低，因为子类必须拥有父类的属性和方法。

#### 4.依赖倒置原则，DIP

​		让项目拥有变化的能力，依赖倒置原则，Dependence Inversion Principle，DIP的定义是：依赖倒置原则指代了一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节的目的。依赖倒置原则有以下几个关键点：

​		1.高层模块不应该依赖低层模块，两者都应该依赖其抽象；

​		2.抽象不应该依赖细节；

​		3.细节应该依赖抽象。

​		在JAVA语言中的表现就是：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。

#### 5.接口隔离原则，ISP

​		系统有更高的灵活性，接口隔离原则，Interface Segregation Principle，ISP的定义是：客户端不应该依赖它不需要的接口。类间的依赖关系应该建立在最小的接口上。接口隔离原则的目的是系统解开耦和，从而容易重构、更改和重新部署

#### 6.迪米特原则，LOD

​		更好的扩展性，迪米特原则。Law of Demeter —— LOD。也称为最少知识原则，定义是：一个对象应该对其他对象有最少的了解。

### 二.单例模式

#### 1.单例模式的定义

​		确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。使用场景：避免产生多个对象消耗过多的资源，或者某种类型的对象只应该有且只有一个。例如，创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源，这时就要考虑使用单例模式。

#### 2.实现单例模式主要有以下几个关键点

​		1.构造函数不对外开放，一般为private。

​		2.通过一个静态方法或者枚举返回单例类对象。

​		3.确保单例类的对象有且只有一个，尤其是在多线程环境下。

​		4.确保单例类对象在反序列化时不会重新构建对象。

#### 3.各种实现方式的优缺点

​		懒汉单例模式的优点是单例只有在使用时才会被实例化，在一定程度上节约了资源；缺点是第一次加载时需要及时进行实例化，反应稍慢，最大的问题是每次调用getInstance都进行同步，造成不必要的同步开销。这种模式一般不建议使用。

```java
public class LazySingleton {
    private static LazySingleton instance;
    private LazySingleton(){}
    public static synchronized LazySingleton getInstance(){
        if(instance == null)
            instance = new LazySingleton();
        return instance;
    }
}
```

Double Check Lock（DCL）实现单例。JDK1.5以后只需要使用volatile关键字就可以保证sInstance对象每次都是从主内存中读取。DCL虽然在一定程度上解决了资源消耗、多余的同步、线程安全等问题，但是它还是在某些情况下出现失效的问题。(sInstance = new DCLSingleton();是一行代码，但实际上不是一个原子操作，这句代码最终会被编译成多条汇编指令，由于Java编译器允许处理器乱序执行，以及JDK1.5之前JMM中Cache、寄存器到主内存回写顺序的规定，上面的第二第三条指令的顺序是无法保证的。)这个问题被称为双重检查锁定（DCL）失效。DCL的优点：资源利用率高，第一次执行getInstance时单例对象才会被实例化，效率高。缺点：第一次加载时反应稍慢，也由于Java内存模型的原因偶尔会失败。在高并发环境下也有一定的缺陷，虽然发生概率很小。

```java
public class DCLSingleton {
    private static DCLSingleton sInstance = null;
    private DCLSingleton(){}
    public void doSomething(){
        System.out.println("do sth");
    }
    public static synchronized DCLSingleton getInstance(){
        if(sInstance == null){
            synchronized(DCLSingleton.class){
                if(sInstance == null){
                    sInstance = new DCLSingleton();
                }
            }
        }
        return sInstance;
    }
}
```

因此建议使用静态内部类单例模式。

```java
public class Singleton{
	private Singleton(){}
  public static Singleton getInstance(){
    return SingletonHolder.sInstance;
  }
  private static class SingletonHolder{
    private static final Singleton sInstance = new Singleton();
  }
}
```

枚举单例

```java
public enum  EnumSingleton {
    INSTANCE;
    public void doSomething(){
        System.out.println("do sth");
    }
}
```

容器实现单例

```java
public class ContainerSingletonManager {
    private static Map<String,Object> objMap = new HashMap<>();
    
    private ContainerSingletonManager(){}
    public static void registerService(String key,Object instance){
        if(!objMap.containsKey(key))
            objMap.put(key,instance);
    }
    
    public static Object getService(String key){
        return objMap.get(key);
    }
}
```

以上单例模式实现方式在通过序列化可以将一个单例的实例对象写到磁盘，然后再读回来，从而有效地获得一个实例。即使构造函数是私有的，反序列化时依然可以通过特殊途径去创建类的一个新的实例，相当于调用该类的构造函数。使用枚举单例，可以避免这个问题。如果要杜绝单例对象在被反序列化时重新生成对象，那么必须加入readResolve函数。

#### 4.总结

​		单例模式是运用频率很高的模式，但是，由于在客户端通常没有高并发的情况，因此选择哪种实现方式并不会有太大的影响。

​		优点：

​		1.由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。

​		2.由于单例模式只生成一个实例，所以，减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时，直接产生一个单例对象，然后用永久驻留内存的方式来解决。

​		3.单例模式可以避免对资源的多重占用，例如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。

​		4.单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如设计一个单例类，负责所有数据表的映射处理。

​		缺点：

​		1.单例模式一般没有接口，扩展困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。

​		2.单例对象如果持有Context，那么很容易引发内存泄漏，此时需要注意传递给单例对象的Context，最好是Application Context。

### 三.Builder模式

#### 1.Builder模式的定义

​		Builder模式是一步步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。

#### 2.Builder模式的使用场景

​		1.相同的方法，不同的执行顺序，产生不同的事件结果时。

​		2.多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时。

​		3.产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候使用建造者模式非常合适。

​		4.当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时。

#### 3.Builder模式的优缺点

​		通过将构造函数、字段的私有化，使得外部不能访问内部属性，用户唯一能够设置属性的地方就是通过Builder对象，这就是构建和表示相分离。

​		优点：

​		1.良好的封装性，使用建造者模式可以使客户端不必知道产品内部组成的细节。

​		2.建造者独立，容易扩展。

​		缺点：

​		1.会产生多余的Builder对象以及Director对象，消耗内存。	

#### 4.总结

​		Builder模式在Android开发中也较为常用，通常作为配置类的构建器将配置的构建和表示分离开来，同时也是将配置从目标类中隔离出来，避免过多的setter方法。Builder模式比较常见的实现形式是通过调用链实现，这样使得代码更简介、易懂，避免了目标类中被过多的接口“污染”。

### 四.原型模式

#### 1.原型模式的定义

​		原型模式是一个创建型的模式。原型二字表明了该模式应该有一个样板实例，用户从这个样板对象中复制出一个内部属性一致的对象，这个过程也就是我们俗称的“克隆”。被复制的实例就是我们所称的“原型”，这个原型是可定制的。原型模式多用于创建复杂的或者构建耗时的实例。

#### 2.原型模式的使用场景

​		1.类初始化需要消化非常多的资源，这个资源包括数组、硬件资源等，通过原型拷贝避免这些消耗。

​		2.通过new产生一个对象需要非常繁琐的数据准备或访问权限。

​		3.一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。

​		4.需要注意的是，通过实现cloneable接口的原型模式在调用clone函数构造实例时并不一定比通过new操作速度快，只有当通过new构造对象较为耗时或者说成本较高时，通过clone方法才能获得效率上的提升。因此，在使用cloneable时需要考虑构建对象的成本以及做一些效率上的测试。当然，实现原型模式也不一定非要实现Cloneable接口，也有其他的实现方式。

#### 3.注意事项

​		1.注意浅copy和深copy问题。建议尽量使用深拷贝，避免操作副本时影响原始对象的问题。

​		2.使用clone和new需要根据构造对象的成本来决定，如果对象的构造成本比较高或者构造较为麻烦，那么使用clone函数效率较高，否则可以使用new的形式。

#### 4.原型模式的优缺点

​		优点：

​		原型模式是在内存中二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。

​		缺点：

​		这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的，在实际开发当中应该注意这个潜在的问题。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。

#### 5.总结

​		1.原型模式本质上就是对象拷贝，与C++中的拷贝构造函数有些类似，它们之间容易出现的问题也都是深拷贝、浅拷贝。使用原型模式可以解决构建复杂对象的资源消耗问题，能够在某些场景下提升创建对象的效率。还有一个重要的用途就是保护性拷贝，也就是某个对象对外可能是只读的，为了防止外部对这个对象修改，通常可以通过返回一个对象拷贝的形式实现只读的限制。