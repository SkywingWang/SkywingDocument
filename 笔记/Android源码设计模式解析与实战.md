示例代码Github地址：https://github.com/SkywingWang/DesignPatterns

### 一.面向对象的六大原则

#### 1.单一职责原则，SRP

​		单一职责原则，Single Responsibility Principle，SRP的定义是：就一个类而言，应该仅有一个引起它变化的原因。

#### 2.开闭原则，OCP

​		让程序更稳定、更灵活，开闭原则，Open Close Principle，OCP的定义是：软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的。

#### 3.里氏替换原则，LSP

​		构建扩展性更好的系统，里氏替换原则，Liskov Substitution Principle，LSP的定义是：如果对每一个类型为S的对象O1，都有类型为T的对象O2，使得以T定义的所有程序P在所有的对象O1都代换成O2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。或称，所有引用基类的地方必须透明地使用其子类的对象。里氏替换原则的核心原理是抽象，抽象又依赖于继承这个特性。在OOP当中，继承的优缺点都相当明显。

优点有以下几点：

​		1.代码重用，减少创建类的成本，每个子类都拥有父类的方法和属性；

​		2.子类与父类基本相似，但又与父类有所区别；

​		3.提高代码的可扩展性。

继承的缺点：

​		1.继承是侵入性的，只要继承就必须拥有父类的所有属性和方法；

​		2.可能造成子类代码冗余、灵活性降低，因为子类必须拥有父类的属性和方法。

#### 4.依赖倒置原则，DIP

​		让项目拥有变化的能力，依赖倒置原则，Dependence Inversion Principle，DIP的定义是：依赖倒置原则指代了一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节的目的。依赖倒置原则有以下几个关键点：

​		1.高层模块不应该依赖低层模块，两者都应该依赖其抽象；

​		2.抽象不应该依赖细节；

​		3.细节应该依赖抽象。

​		在JAVA语言中的表现就是：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。

#### 5.接口隔离原则，ISP

​		系统有更高的灵活性，接口隔离原则，Interface Segregation Principle，ISP的定义是：客户端不应该依赖它不需要的接口。类间的依赖关系应该建立在最小的接口上。接口隔离原则的目的是系统解开耦和，从而容易重构、更改和重新部署

#### 6.迪米特原则，LOD

​		更好的扩展性，迪米特原则。Law of Demeter —— LOD。也称为最少知识原则，定义是：一个对象应该对其他对象有最少的了解。

### 二.单例模式

#### 1.单例模式的定义

​		确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。使用场景：避免产生多个对象消耗过多的资源，或者某种类型的对象只应该有且只有一个。例如，创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源，这时就要考虑使用单例模式。

#### 2.实现单例模式主要有以下几个关键点

​		1.构造函数不对外开放，一般为private。

​		2.通过一个静态方法或者枚举返回单例类对象。

​		3.确保单例类的对象有且只有一个，尤其是在多线程环境下。

​		4.确保单例类对象在反序列化时不会重新构建对象。

#### 3.各种实现方式的优缺点

​		懒汉单例模式的优点是单例只有在使用时才会被实例化，在一定程度上节约了资源；缺点是第一次加载时需要及时进行实例化，反应稍慢，最大的问题是每次调用getInstance都进行同步，造成不必要的同步开销。这种模式一般不建议使用。

```java
public class LazySingleton {
    private static LazySingleton instance;
    private LazySingleton(){}
    public static synchronized LazySingleton getInstance(){
        if(instance == null)
            instance = new LazySingleton();
        return instance;
    }
}
```

Double Check Lock（DCL）实现单例。JDK1.5以后只需要使用volatile关键字就可以保证sInstance对象每次都是从主内存中读取。DCL虽然在一定程度上解决了资源消耗、多余的同步、线程安全等问题，但是它还是在某些情况下出现失效的问题。(sInstance = new DCLSingleton();是一行代码，但实际上不是一个原子操作，这句代码最终会被编译成多条汇编指令，由于Java编译器允许处理器乱序执行，以及JDK1.5之前JMM中Cache、寄存器到主内存回写顺序的规定，上面的第二第三条指令的顺序是无法保证的。)这个问题被称为双重检查锁定（DCL）失效。DCL的优点：资源利用率高，第一次执行getInstance时单例对象才会被实例化，效率高。缺点：第一次加载时反应稍慢，也由于Java内存模型的原因偶尔会失败。在高并发环境下也有一定的缺陷，虽然发生概率很小。

```java
public class DCLSingleton {
    private static DCLSingleton sInstance = null;
    private DCLSingleton(){}
    public void doSomething(){
        System.out.println("do sth");
    }
    public static synchronized DCLSingleton getInstance(){
        if(sInstance == null){
            synchronized(DCLSingleton.class){
                if(sInstance == null){
                    sInstance = new DCLSingleton();
                }
            }
        }
        return sInstance;
    }
}
```

因此建议使用静态内部类单例模式。

```java
public class Singleton{
	private Singleton(){}
  public static Singleton getInstance(){
    return SingletonHolder.sInstance;
  }
  private static class SingletonHolder{
    private static final Singleton sInstance = new Singleton();
  }
}
```

枚举单例

```java
public enum  EnumSingleton {
    INSTANCE;
    public void doSomething(){
        System.out.println("do sth");
    }
}
```

容器实现单例

```java
public class ContainerSingletonManager {
    private static Map<String,Object> objMap = new HashMap<>();
    
    private ContainerSingletonManager(){}
    public static void registerService(String key,Object instance){
        if(!objMap.containsKey(key))
            objMap.put(key,instance);
    }
    
    public static Object getService(String key){
        return objMap.get(key);
    }
}
```

以上单例模式实现方式在通过序列化可以将一个单例的实例对象写到磁盘，然后再读回来，从而有效地获得一个实例。即使构造函数是私有的，反序列化时依然可以通过特殊途径去创建类的一个新的实例，相当于调用该类的构造函数。使用枚举单例，可以避免这个问题。如果要杜绝单例对象在被反序列化时重新生成对象，那么必须加入readResolve函数。

#### 4.总结

​		单例模式是运用频率很高的模式，但是，由于在客户端通常没有高并发的情况，因此选择哪种实现方式并不会有太大的影响。

​		优点：

​		1.由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。

​		2.由于单例模式只生成一个实例，所以，减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时，直接产生一个单例对象，然后用永久驻留内存的方式来解决。

​		3.单例模式可以避免对资源的多重占用，例如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。

​		4.单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如设计一个单例类，负责所有数据表的映射处理。

​		缺点：

​		1.单例模式一般没有接口，扩展困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。

​		2.单例对象如果持有Context，那么很容易引发内存泄漏，此时需要注意传递给单例对象的Context，最好是Application Context。

### 三.Builder模式

#### 1.Builder模式的定义

​		Builder模式是一步步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。

#### 2.Builder模式的使用场景

​		1.相同的方法，不同的执行顺序，产生不同的事件结果时。

​		2.多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时。

​		3.产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候使用建造者模式非常合适。

​		4.当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时。

#### 3.Builder模式的优缺点

​		通过将构造函数、字段的私有化，使得外部不能访问内部属性，用户唯一能够设置属性的地方就是通过Builder对象，这就是构建和表示相分离。

​		优点：

​		1.良好的封装性，使用建造者模式可以使客户端不必知道产品内部组成的细节。

​		2.建造者独立，容易扩展。

​		缺点：

​		1.会产生多余的Builder对象以及Director对象，消耗内存。	

#### 4.总结

​		Builder模式在Android开发中也较为常用，通常作为配置类的构建器将配置的构建和表示分离开来，同时也是将配置从目标类中隔离出来，避免过多的setter方法。Builder模式比较常见的实现形式是通过调用链实现，这样使得代码更简介、易懂，避免了目标类中被过多的接口“污染”。

### 四.原型模式

#### 1.原型模式的定义

​		原型模式是一个创建型的模式。原型二字表明了该模式应该有一个样板实例，用户从这个样板对象中复制出一个内部属性一致的对象，这个过程也就是我们俗称的“克隆”。被复制的实例就是我们所称的“原型”，这个原型是可定制的。原型模式多用于创建复杂的或者构建耗时的实例。

#### 2.原型模式的使用场景

​		1.类初始化需要消化非常多的资源，这个资源包括数组、硬件资源等，通过原型拷贝避免这些消耗。

​		2.通过new产生一个对象需要非常繁琐的数据准备或访问权限。

​		3.一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。

​		4.需要注意的是，通过实现cloneable接口的原型模式在调用clone函数构造实例时并不一定比通过new操作速度快，只有当通过new构造对象较为耗时或者说成本较高时，通过clone方法才能获得效率上的提升。因此，在使用cloneable时需要考虑构建对象的成本以及做一些效率上的测试。当然，实现原型模式也不一定非要实现Cloneable接口，也有其他的实现方式。

#### 3.注意事项

​		1.注意浅copy和深copy问题。建议尽量使用深拷贝，避免操作副本时影响原始对象的问题。

​		2.使用clone和new需要根据构造对象的成本来决定，如果对象的构造成本比较高或者构造较为麻烦，那么使用clone函数效率较高，否则可以使用new的形式。

#### 4.原型模式的优缺点

​		优点：

​		原型模式是在内存中二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。

​		缺点：

​		这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的，在实际开发当中应该注意这个潜在的问题。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。

#### 5.总结

​		1.原型模式本质上就是对象拷贝，与C++中的拷贝构造函数有些类似，它们之间容易出现的问题也都是深拷贝、浅拷贝。使用原型模式可以解决构建复杂对象的资源消耗问题，能够在某些场景下提升创建对象的效率。还有一个重要的用途就是保护性拷贝，也就是某个对象对外可能是只读的，为了防止外部对这个对象修改，通常可以通过返回一个对象拷贝的形式实现只读的限制。

### 五.工厂模式

#### 1.工厂模式的定义

​		工厂模式定义一个用于创建对象的接口，让子类决定实例化哪个类。

#### 2.工厂模式的使用场景

​		在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂模式，用new就可以完成创建的对象无需使用工厂模式。

#### 3.总结

​		工厂类的缺点在于，每次我们为工厂方法模式添加新的产品时，就要编写一个新的产品类，同时还要引入抽象层，这必然会导致类结构的复杂化，所以，在某些情况比较简单的时候，是否要使用工厂模式，需要设计者权衡利弊了。

### 六.抽象工厂模式

#### 1.抽象工厂模式的定义

​		抽象工厂模式(Abstract Factory Pattem)，也是创建型设计模式之一。为创建一组相关或者互相依赖的对象提供一个接口，而不需要指定它们的具体类。

#### 2.抽象工厂方法模式的分类

​		抽象工厂方法模式的种类繁多，但主要分为四类：

​		1.AbstractFactory：抽象工厂角色，它声明了一组用于创建一种产品的方法，每一个方法对应一种产品。

​		2.ConcreteFactory：具体工厂角色，它实现了在抽象工厂中定义的创建产品的方法，生产一组具体产品，这些产品构成了一个产品种类，每一个产品都位于某个产品等级结构中。

​		3.AbstractProduct：抽象产品角色，它为每种产品声明接口，比如上述类图中的AbstractProductA和AbstractProductB。

​		4.ConcreteProduct：具体产品角色，它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。

#### 3.总结

​		抽象工厂方法模式的优点，一个显著优点是分离接口与实现，客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已，使其从具体的产品实现中解耦，同时基于接口与实现的分离，使抽象该工厂方法模式在切换产品类时更加灵活、容易。抽象工厂方法模式的缺点：一是类文件的爆炸性增加，二是不太容易扩展新的产品类。

### 七.策略模式

#### 1.策略模式的定义

​		策略模式定义了系列的算法，并将每个算法封装起来，而且使它们还可以互相替换。策略模式让算法独立于使用它的客户而独立变化。

#### 2.策略模式的使用场景

​		针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。需要安全地封装多种同一类型的操作时。出现同一抽象类有多个子类，而又需要使用if-else或者switch-case来选择具体子类时。

#### 3.总结

​		策略模式主要用来分离算法，在相同的行为抽象下有不同的具体实现策略。这个模式很好的演示了开闭原则，也就是定义抽象，注入不同的实现，从而达到很好的可扩展性。

​		优点，结构清晰明了，使用简单直观。耦合度相对较低，扩展方便。操作封装也更为彻底，数据更为安全。

​		缺点，随着策略的增加，子类也会变的繁多。

### 8.状态模式

#### 1.状态模式的定义

​		当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。

#### 2.状态模式的使用场景

​		1.一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。

​		2.代码中包含大量与对象状态有关的条件语句，且这些分支依赖于该对象的状态。

​		状态模式将每一个条件分支放入一个独立的类中，这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化，这样通过多态来去除过多的、重复的if-else等分支语句。

#### 3.总结

​		状态模式的关键点在于不同的状态对于同一行为有不同的响应，这其实就是一个将if-else用多态来实现的一个具体示例。

​		状态模式的优点：

​		State模式将所有与一个特定的状态相关的行为都放入一个状态对象中，它提供了一个更好的方式来组织与特定状态相关的代码，将繁琐的状态判断转换成结构清晰的状态类族，在避免代码膨胀的同时，也保证了可扩展性与可维护性。

​		状态模式的缺点：

​		状态模式的使用必然会增加系统类和对象的个数。

### 9.责任链模式

#### 1.责任链模式定义

​		使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，只到有对象处理它为止。

#### 2.责任链模式的使用场景

​		多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定。在请求处理者不明确的情况下向多个对象中的一个提交一个请求。需要动态指定一组对象处理请求。

#### 3.总结

​		责任链模式的优点：可以对请求者和处理者关系解耦，提高代码的灵活性。责任链模式的最大缺点是对链中请求处理者的遍历，如果处理者太多那么遍历必定会影响性能，特别是一些递归调用中。

### 10.解释器模式

#### 1.解释器模式介绍

​		解释器模式是一种用的比较少的行为型模式，其提供了一种解释语言的语法或表达式的方式，该模式定义了一个表达式接口，通过该接口解释一个特定的上下文。

#### 2.解释器模式的定义

​		给定一个语言，定义它的文化的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

#### 3.总结

​		优点：解释器模式的优点我们在本文的两个例子中已有所提及，最大的优点是其灵活的扩展性，当我们想对文法规则进行扩展延伸时，只需要增加相应的非终结符解释器，并在构建抽象语法树时，使用到新增的解释器对象进行具体的解释即可。

​		缺点：解释器模式的缺点也显而易见，因为对每一条文法都可以对应至少一个解释器，其会生成大量的类，导致后期维护困难；同时，对于过于复杂的文法，构建其抽象语法树会显得异常烦琐，甚至可能会出现需要构建多棵抽象语法树的情况。因此，对于复杂的文法，并不推荐使用解释器模式。

### 11.命令模式

#### 1.命令模式介绍

​		命令模式是行为型设计模式之一。将一系列的方法调用封装，用户只需要调用一个方法执行，那么所有这些被封装的方法就会被挨个执行调用。

#### 2.命令模式的定义

​		将一个请求封装成一个对象，从而让用户使用不同的请求把客户端参数化;对请求排队或者记录请求日志，以及支持可撤销的操作。

#### 3.命令模式的使用场景

​		需要抽象出待执行的动作，然后以参数的形式提供出来——类似于过程设计的回调机制，而命令模式正是回调机制的一个面向对象的替代品。在不同的时刻指定、排列和执行请求。一个命令对象可以有与初始请求无关的生存期。需要支持取消操作。支持修改日志功能，这样当系统崩溃时，这些修改可以被重新做一遍。需要支持事务操作。

#### 4.总结

​		在命令模式中其充分体现了几乎所有设计模式的通病，就是类的膨胀，大量衍生类的创建。优点是，更弱的耦合性，更灵活的控制性以及更好的扩展性。

### 12.观察者模式

#### 1.定义

​		定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

#### 2.观察者模式的使用场景

1. 关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。

2. 事件多级触发场景
3. 跨系统的消息交换场景，如消息队列、事件总线的处理机制。

